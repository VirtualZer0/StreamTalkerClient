using Avalonia.Threading;
using Microsoft.Extensions.Logging;
using StreamTalkerClient.Models;
using StreamTalkerClient.Services;

namespace StreamTalkerClient.ViewModels;

/// <summary>
/// Property change handler methods for MainWindowViewModel.
/// Contains all partial void OnXxxChanged() methods generated by CommunityToolkit.Mvvm
/// that respond to observable property changes.
/// </summary>
public partial class MainWindowViewModel
{
    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Voice / Extraction
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Updates the default voice in settings and queue manager when a new voice is selected.
    /// </summary>
    partial void OnSelectedVoiceChanged(VoiceInfo? value)
    {
        if (!_isInitialized || value == null)
            return;

        _settings.Voice.DefaultVoice = value.Name;
        _queueManager.DefaultVoice = value.Name;
        SaveSettings();
    }

    /// <summary>
    /// Updates the volume display text and persists the volume setting.
    /// </summary>
    partial void OnVolumeChanged(int value)
    {
        VolumeText = $"{value}%";
        if (_isInitialized)
        {
            _settings.Audio.VolumePercent = value;
        }
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Twitch Settings
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Persists the Twitch "read all messages" setting on change.
    /// </summary>
    partial void OnReadAllMessagesChanged(bool value)
    {
        if (_isInitialized)
        {
            _settings.Services.Twitch.ReadAllMessages = value;
            SaveSettings();
        }
    }

    /// <summary>
    /// Persists the Twitch "require voice" setting and updates the queue manager.
    /// </summary>
    partial void OnRequireVoiceChanged(bool value)
    {
        if (_isInitialized)
        {
            _settings.Services.Twitch.RequireVoice = value;
            _queueManager.RequireVoice = value;
            SaveSettings();
        }
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - VK Play Settings
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Persists the VK Play "read all messages" setting on change.
    /// </summary>
    partial void OnVkReadAllMessagesChanged(bool value)
    {
        if (_isInitialized)
        {
            _settings.Services.VKPlay.ReadAllMessages = value;
            SaveSettings();
        }
    }

    /// <summary>
    /// Persists the VK Play "require voice" setting on change.
    /// </summary>
    partial void OnVkRequireVoiceChanged(bool value)
    {
        if (_isInitialized)
        {
            _settings.Services.VKPlay.RequireVoice = value;
            SaveSettings();
        }
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Voice Extraction
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Updates the voice extraction mode in settings and queue manager
    /// when the extraction mode dropdown selection changes.
    /// </summary>
    partial void OnSelectedExtractionModeIndexChanged(int value)
    {
        if (!_isInitialized)
            return;

        var mode = value == 1 ? "firstword" : "bracket";
        _settings.Voice.VoiceExtractionMode = mode;
        _queueManager.VoiceExtractionMode = mode;
        SaveSettings();
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Model Configuration
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Updates the DoSample setting in settings, queue manager, and orchestrator.
    /// </summary>
    partial void OnDoSampleChanged(bool value)
    {
        if (_isInitialized)
        {
            _settings.Inference.DoSample = value;
            _queueManager.DoSample = value;
            _orchestrator.DoSample = value;
            SaveSettings();
        }
    }

    /// <summary>
    /// Handles model selection changes. If a different model is selected while
    /// one is currently loaded, triggers a full model switch operation.
    /// </summary>
    partial void OnSelectedModelChanged(string? value)
    {
        OnPropertyChanged(nameof(SelectedModelIndex));

        if (!_isInitialized || string.IsNullOrEmpty(value))
            return;

        _settings.Model.Core.Name = value;
        _queueManager.ModelName = value;
        _orchestrator.Model = value;

        // If model is currently loaded and we switched to a different model, do a full switch
        if (IsModelLoaded && !IsModelOperationInProgress && !_suppressModelSwitch)
        {
            _ = SwitchModelAsync(value);
        }
        else
        {
            // Just update model status display from last known status
            _ = Task.Run(async () =>
            {
                try
                {
                    var status = await _ttsClient.GetModelsStatusAsync();
                    if (status != null)
                    {
                        Dispatcher.UIThread.Post(() => UpdateModelStatusDisplay(status));
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogDebug(ex, "Failed to update model status on selection change");
                }
            });
        }

        SaveSettings();
    }

    /// <summary>
    /// Persists the selected attention mechanism to settings.
    /// </summary>
    partial void OnSelectedAttentionChanged(string? value)
    {
        if (_isInitialized && value != null)
        {
            _settings.Model.Core.Attention = value;
            SaveSettings();
        }
    }

    /// <summary>
    /// Persists the selected quantization mode and updates the queue manager.
    /// </summary>
    partial void OnSelectedQuantizationChanged(string? value)
    {
        if (!_isInitialized || value == null)
            return;

        _settings.Model.Core.Quantization = value;
        _queueManager.Quantization = value;
        SaveSettings();
    }

    /// <summary>
    /// Handles auto-unload toggle changes. When enabled with a loaded model,
    /// sets the auto-unload timer on the server.
    /// </summary>
    partial void OnAutoUnloadChanged(bool value)
    {
        if (!_isInitialized)
            return;

        _settings.Model.AutoUnload.Enabled = value;
        SaveSettings();

        if (!IsServerAvailable || string.IsNullOrEmpty(SelectedModel))
            return;

        if (value && AutoUnloadMinutes > 0)
        {
            _ = _ttsClient.SetAutoUnloadAsync(SelectedModel, AutoUnloadMinutes);
        }
        else if (!value)
        {
            // Disable = send 0 minutes to API
            _ = _ttsClient.SetAutoUnloadAsync(SelectedModel, 0);
        }
    }

    /// <summary>
    /// Handles auto-unload minutes changes. Updates the server timer
    /// when auto-unload is enabled and a model is loaded.
    /// </summary>
    partial void OnAutoUnloadMinutesChanged(int value)
    {
        if (!_isInitialized)
            return;

        _settings.Model.AutoUnload.Minutes = value;
        SaveSettings();

        if (AutoUnload && IsServerAvailable && !string.IsNullOrEmpty(SelectedModel) && value > 0)
        {
            _ = _ttsClient.SetAutoUnloadAsync(SelectedModel, value);
        }
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Server / Playback Settings
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Persists the playback delay and updates the playback controller.
    /// </summary>
    partial void OnPlaybackDelayChanged(int value)
    {
        if (_isInitialized)
        {
            _settings.Audio.PlaybackDelaySeconds = value;
            _playbackController.PlaybackDelaySeconds = value;
            SaveSettings();
        }
    }

    /// <summary>
    /// Persists the cache limit and updates the cache manager.
    /// </summary>
    partial void OnCacheLimitMBChanged(int value)
    {
        if (_isInitialized)
        {
            _settings.Cache.LimitMB = value;
            _cacheManager.SetCacheLimit(value);
            SaveSettings();
        }
    }

    /// <summary>
    /// Handles TTS server URL changes. Updates the HTTP client base URL,
    /// persists the setting, and triggers an immediate health check.
    /// </summary>
    partial void OnTtsServerUrlChanged(string value)
    {
        if (!_isInitialized || string.IsNullOrWhiteSpace(value))
            return;

        try
        {
            _ttsClient.SetBaseUrl(value);
            _settings.Server.BaseUrl = value;
            SaveSettings();

            // Trigger immediate health check
            _ = Task.Run(async () =>
            {
                var healthy = await _ttsClient.CheckHealthAsync();
                Dispatcher.UIThread.Post(() => UpdateServerStatus(healthy));
            });
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Invalid TTS server URL: {Url}", value);
        }
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Language
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Handles UI language index changes. Swaps the resource dictionary
    /// and refreshes all status displays for the new language.
    /// </summary>
    partial void OnSelectedLanguageIndexChanged(int value)
    {
        if (!_isInitialized)
            return;

        var langCode = value == 1 ? "ru" : "en";

        // Use App.SetLanguage which handles the resource dictionary swap properly
        App.SetLanguage(langCode);

        // Refresh all status displays to pick up new language strings
        RefreshAllStatusDisplays();

        _settings.Metadata.LanguageUI = langCode;
        SaveSettings();
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Model Load Options
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Persists the selected warmup mode.
    /// </summary>
    partial void OnSelectedWarmupChanged(string value)
    {
        if (_isInitialized)
        {
            _settings.Model.Warmup.Mode = value ?? "none";
            SaveSettings();
        }
    }

    /// <summary>
    /// Persists the force-CPU setting.
    /// </summary>
    partial void OnForceCpuChanged(bool value)
    {
        if (_isInitialized)
        {
            _settings.Model.Core.ForceCpu = value;
            SaveSettings();
        }
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Optimization Flags
    // ═══════════════════════════════════════════════════════════

    /// <summary>Persists the enable-optimizations flag.</summary>
    partial void OnEnableOptimizationsChanged(bool value)
    {
        if (_isInitialized) { _settings.Model.Optimizations.Enabled = value; /* Settings saved by auto-save timer */ }
    }

    /// <summary>Persists the torch-compile flag.</summary>
    partial void OnTorchCompileChanged(bool value)
    {
        if (_isInitialized) { _settings.Model.Optimizations.TorchCompile = value; /* Settings saved by auto-save timer */ }
    }

    /// <summary>Persists the CUDA graphs flag.</summary>
    partial void OnCudaGraphsChanged(bool value)
    {
        if (_isInitialized) { _settings.Model.Optimizations.CudaGraphs = value; /* Settings saved by auto-save timer */ }
    }

    /// <summary>Persists the compile-codebook flag.</summary>
    partial void OnCompileCodebookChanged(bool value)
    {
        if (_isInitialized) { _settings.Model.Optimizations.CompileCodebook = value; /* Settings saved by auto-save timer */ }
    }

    /// <summary>Persists the fast-codebook flag.</summary>
    partial void OnFastCodebookChanged(bool value)
    {
        if (_isInitialized) { _settings.Model.Optimizations.FastCodebook = value; /* Settings saved by auto-save timer */ }
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Warmup Sub-parameters
    // ═══════════════════════════════════════════════════════════

    /// <summary>Persists the warmup language.</summary>
    partial void OnWarmupLangChanged(string value)
    {
        if (_isInitialized) { _settings.Model.Warmup.Language = value; /* Settings saved by auto-save timer */ }
    }

    /// <summary>Persists the warmup voice name.</summary>
    partial void OnWarmupVoiceChanged(string value)
    {
        if (_isInitialized) { _settings.Model.Warmup.Voice = value; /* Settings saved by auto-save timer */ }
    }

    /// <summary>Syncs the selected warmup VoiceInfo to the string WarmupVoice property.</summary>
    partial void OnSelectedWarmupVoiceChanged(VoiceInfo? value)
    {
        if (_isInitialized && value != null)
        {
            WarmupVoice = value.Name;
        }
    }

    /// <summary>Persists the warmup timeout.</summary>
    partial void OnWarmupTimeoutChanged(int value)
    {
        if (_isInitialized) { _settings.Model.Warmup.TimeoutSeconds = value; /* Settings saved by auto-save timer */ }
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Inference Parameters
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Persists the TTS speed and updates the queue manager and orchestrator.
    /// </summary>
    partial void OnSpeedChanged(double value)
    {
        if (_isInitialized)
        {
            _settings.Voice.Speed = value;
            _queueManager.Speed = value;
            _orchestrator.Speed = value;
            SaveSettings();
        }
    }

    /// <summary>
    /// Persists the TTS temperature and updates the queue manager and orchestrator.
    /// </summary>
    partial void OnTemperatureChanged(double value)
    {
        if (_isInitialized)
        {
            _settings.Voice.Temperature = value;
            _queueManager.Temperature = value;
            _orchestrator.Temperature = value;
            SaveSettings();
        }
    }

    /// <summary>
    /// Persists the max-new-tokens limit and updates the queue manager and orchestrator.
    /// </summary>
    partial void OnMaxNewTokensChanged(int value)
    {
        if (_isInitialized)
        {
            _settings.Voice.MaxNewTokens = value;
            _queueManager.MaxNewTokens = value;
            _orchestrator.MaxNewTokens = value;
            SaveSettings();
        }
    }

    /// <summary>
    /// Persists the repetition penalty and updates the queue manager and orchestrator.
    /// </summary>
    partial void OnRepetitionPenaltyChanged(double value)
    {
        if (_isInitialized)
        {
            _settings.Voice.RepetitionPenalty = value;
            _queueManager.RepetitionPenalty = value;
            _orchestrator.RepetitionPenalty = value;
            SaveSettings();
        }
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - TTS Language
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Persists the selected TTS synthesis language and updates the orchestrator.
    /// </summary>
    partial void OnSelectedTtsLanguageChanged(string value)
    {
        if (!_isInitialized || string.IsNullOrEmpty(value))
            return;

        _settings.Server.Language = value;
        _queueManager.Language = value;
        _orchestrator.Language = value;
        SaveSettings();
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - GPU / VRAM
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Handles VRAM slider changes with debouncing. Sends the new max VRAM limit
    /// to the TTS server after a 500ms delay to avoid excessive API calls.
    /// </summary>
    partial void OnMaxVramSliderValueChanged(int value)
    {
        if (!_isInitialized || !IsServerAvailable)
            return;

        MaxVramText = string.Format(GetLocalizedString("MaxVramFormat", "Max VRAM: {0:F0} MB"), value);
        UpdateVramLimit();

        // Cancel previous pending request
        _vramDebounceCts?.Cancel();
        _vramDebounceCts?.Dispose();
        var cts = _vramDebounceCts = new CancellationTokenSource();

        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(500, cts.Token);
                var result = await _ttsClient.SetMaxVramAsync(value);
                if (result != null)
                {
                    Dispatcher.UIThread.Post(() =>
                    {
                        MaxVramText = string.Format(GetLocalizedString("MaxVramFormat", "Max VRAM: {0:F0} MB"), result.MaxVramMb);
                    });
                }
            }
            catch (OperationCanceledException)
            {
                // Expected - newer slider value superseded this one
            }
            catch (Exception ex)
            {
                _logger.LogDebug(ex, "Failed to set max VRAM");
            }
        });
    }

    // ═══════════════════════════════════════════════════════════
    //  PROPERTY CHANGE HANDLERS - Reward Selection
    // ═══════════════════════════════════════════════════════════

    /// <summary>
    /// Persists settings when the Twitch reward selection changes.
    /// </summary>
    partial void OnSelectedRewardIndexChanged(int value)
    {
        if (_isInitialized)
        {
            SaveSettings();
        }
    }

    /// <summary>
    /// Persists settings when the VK Play reward selection changes.
    /// </summary>
    partial void OnSelectedVkRewardIndexChanged(int value)
    {
        if (_isInitialized)
        {
            SaveSettings();
        }
    }
}
